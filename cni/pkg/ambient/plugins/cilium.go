package plugins

import (
	"context"
	"errors"
	"fmt"
	"github.com/cilium/cilium/pkg/k8s/apis/cilium.io/v2"
	v1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/meta/v1"
	"github.com/cilium/cilium/pkg/policy/api"
	"istio.io/istio/pkg/kube"
	"istio.io/istio/pkg/log"
	"istio.io/istio/pkg/util/sets"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type CiliumFactory struct {
}

func (c *CiliumFactory) Create(ctx context.Context, kubeClient kube.Client) (*CiliumPlugin, error) {
	// Check if cilium is installed
	resp, err := kubeClient.Ext().ApiextensionsV1beta1().CustomResourceDefinitions().Get(ctx, "ciliumlocalredirectpolicies.cilium.io", metav1.GetOptions{})
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("cilium CRD for local redirect policies not found")
	}
	return &CiliumPlugin{
		ctx:        ctx,
		kubeClient: kubeClient,
	}, nil
}

type CiliumPlugin struct {
	ctx          context.Context
	kubeClient   kube.Client
	ztunnelPod   *corev1.Pod
	enrolledPods sets.Set[string]
	policies     map[string]v2.CiliumLocalRedirectPolicy
}

func (c *CiliumPlugin) UpdateHostIP(hostIps []string) error {
	// Do nothing, as cilium does not need to know about the host IP
	// only the pod labels
	return nil
}

func (c *CiliumPlugin) UpdateNodeProxy(pod *corev1.Pod, dns bool) {
	c.ztunnelPod = pod
	for _, policy := range c.policies {
		policy.Spec.RedirectBackend.LocalEndpointSelector.MatchLabels = pod.Labels
		if dns {
			log.Infof("DNS is not supported by cilium yet")
		}
		res := c.kubeClient.Ext().ApiextensionsV1beta1().RESTClient().Put().Body(policy).Do(c.ctx)
		if res.Error() != nil {
			log.Errorf("error updating cilium policy: %v", res.Error())
		}
	}
}

func (c *CiliumPlugin) DumpEnrolledIPs() sets.Set[string] {
	return c.enrolledPods
}

func (c *CiliumPlugin) DelPodOnNode(ip string) error {
	if !c.enrolledPods.Contains(ip) {
		return fmt.Errorf("pod %s not enrolled", ip)
	}
	res := c.kubeClient.Ext().ApiextensionsV1beta1().RESTClient().Delete().Body(c.policies[ip]).Do(c.ctx)
	if res.Error() != nil {
		return res.Error()
	}
	// Remove from cache
	c.enrolledPods.Delete(ip)
	delete(c.policies, ip)
	return nil
}

func (c *CiliumPlugin) UpdatePodOnNode(pod *corev1.Pod) error {
	for _, policy := range c.policies {
		if policy.Spec.RedirectFrontend.AddressMatcher.IP == pod.Status.PodIP {
			policy.Spec.RedirectBackend.LocalEndpointSelector.MatchLabels = pod.Labels
			res := c.kubeClient.Ext().ApiextensionsV1beta1().RESTClient().Put().Body(policy).Do(c.ctx)
			if res.Error() != nil {
				return res.Error()
			}
			// Update cache
			c.enrolledPods.Insert(pod.Status.PodIP)
			c.policies[pod.Status.PodIP] = policy
			return nil
		}
	}
	policy := v2.CiliumLocalRedirectPolicy{
		TypeMeta: metav1.TypeMeta{
			Kind:       "CiliumLocalRedirectPolicy",
			APIVersion: "cilium.io/v2",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: fmt.Sprintf("ztunnel-redirect-%s-%s", pod.Status.PodIP, pod.Name),
		},
		Spec: v2.CiliumLocalRedirectPolicySpec{
			RedirectFrontend: v2.RedirectFrontend{
				AddressMatcher: &v2.Frontend{
					IP: pod.Status.PodIP,
				},
			},
			RedirectBackend: v2.RedirectBackend{
				LocalEndpointSelector: v1.LabelSelector{
					MatchLabels: c.ztunnelPod.Labels,
				},
			},
			Description: fmt.Sprintf("ztunnel redirect for pod %s - autogenerated by ambient", pod.Name),
		},
	}
	for _, c := range pod.Spec.Containers {
		for _, p := range c.Ports {
			policy.Spec.RedirectFrontend.AddressMatcher.ToPorts = append(policy.Spec.RedirectFrontend.AddressMatcher.ToPorts, v2.PortInfo{
				Port:     string(p.HostPort),
				Protocol: api.L4Proto(p.Protocol),
				Name:     p.Name,
			})
			policy.Spec.RedirectBackend.ToPorts = append(policy.Spec.RedirectBackend.ToPorts, v2.PortInfo{
				Port:     string(p.ContainerPort),
				Protocol: api.L4Proto(p.Protocol),
				Name:     p.Name,
			})
		}
	}
	res := c.kubeClient.Ext().ApiextensionsV1beta1().RESTClient().Post().Body(policy).Do(c.ctx)
	if res.Error() != nil {
		return res.Error()
	}
	// Update cache
	c.enrolledPods.Insert(pod.Status.PodIP)
	c.policies[pod.Status.PodIP] = policy
	return nil
}

func (c *CiliumPlugin) DelZTunnel() error {
	return c.CleanupPodsOnNode()
}

func (c *CiliumPlugin) CleanupPodsOnNode() error {
	var err error
	for _, policy := range c.policies {
		res := c.kubeClient.Ext().ApiextensionsV1beta1().RESTClient().Delete().Body(policy).Do(c.ctx)
		if res.Error() != nil {
			err = errors.Join(err, res.Error())
		}
	}
	c.enrolledPods = make(sets.Set[string])
	c.policies = make(map[string]v2.CiliumLocalRedirectPolicy)
	return err
}
